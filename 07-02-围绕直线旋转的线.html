<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>圆的切点</title>
    <style>
        html{height: 100%}
        body{height: 100%;margin: 0;}
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script type="module">

    import Vector2 from "./jsm/Vector2.js"
    import Poly from "./jsm/Poly.js"
    import Lattice from "./jsm/modifierLib/Lattice.js"
    import Ball from "./jsm/shapeLib/Ball.js"
    import {getMousePos} from "./jsm/Tool.js";

    const canvas=document.getElementById('canvas');
    canvas.width=window.innerWidth;
    canvas.height=window.innerHeight;

    const ctx=canvas.getContext('2d');

    /*直线l 的起点和终点*/
    const S=new Vector2(300,300);
    const E=new Vector2(500,400);


    /*点P*/
    // const P=new Vector2(600,50);
    const P=new Vector2(0,0);

    /*垂点P0*/
    const P0=new Vector2();

    function updateP0([S,E],P){
        /*过P点做垂线垂直直线l 于点P2*/
        const P2=new Vector2(P.x,0);

        /*直线l的A、B、C*/
        const dta=E.clone().sub(S);
        const k=dta.y/dta.x;
        const b=E.y-E.x*k;

        P2.y=k*P.x+b;

        const A=dta.y;
        const B=-dta.x;
        const C=dta.x*S.y-dta.y*S.x;

        /*距离*/
        const d=(A*P.x+B*P.y+C)/Math.sqrt(A*A+B*B);

        /*P点到P2点的距离*/
        const PP2=P.clone().sub(P2).length();

        /*用三角函数计算P0E的长度*/
        const P2P0=Math.sqrt(PP2*PP2-d*d);

        /*利用三角函数，计算P0点*/
        const dir=S.angleTo(E);
        const x=Math.cos(dir)*P2P0;
        const y=Math.sin(dir)*P2P0;
        // const l1=P.x*Math.cos(dir);
        // const l2=E.x*Math.cos(dir);
        let n1=k>0?1:-1;
        let n2=P.y>P2.y?-1:1;
        let n3=dta.x>0?1:-1;
        let n=n1*n2*n3;
        P0.x=P2.x+x*n;
        P0.y=P2.y+y*n;
    }

    /*晶格化修改器*/
    const lattice=new Lattice();
    /*直线l*/
    const l=new Poly({
        vertices:[S,E],
        stroke:true,
    })
    /*将修改器应用于poly*/
    l.addModifier(lattice);
    /*绘图*/
    // l.draw(ctx);

    /*直线m*/
    const m=new Poly({
        vertices:[P,P0],
        stroke:true,
    })
    /*将修改器应用于poly*/
    m.addModifier(lattice);
    /*绘图*/
    // m.draw(ctx);

    /*更新L 点位*/
    function updateL(S,E){
        const center=S.clone().lerp(E,0.5);
        E.rotateAround(center,0.01);
        S.rotateAround(center,0.01);
    }

    /*让P点成为鼠标点*/
    window.addEventListener('mousemove',function(event){
        const mousePos=getMousePos(event,canvas);
        P.copy(mousePos);
    })

    !(function render(){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        updateL(S,E);
        updateP0([S,E],P);
        l.draw(ctx);
        m.draw(ctx);
        requestAnimationFrame(render);
    })()

</script>
</body>
</html>